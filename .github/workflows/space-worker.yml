name: Space Worker

on:
  workflow_dispatch:
    inputs:
      space_url:
        description: "X Space URL (or direct audio URL)"
        required: true
        type: string
      title:
        description: "Title to use in WP"
        required: false
        default: ""
        type: string
      post_id:
        description: "Existing WP post ID (spaces CPT)"
        required: false
        default: ""
        type: string
      gcs_prefix:
        description: "Optional prefix in the bucket (e.g. spaces/2024/)"
        required: false
        default: ""
        type: string
      make_public:
        description: "Make GCS object public"
        required: false
        default: "true"
        type: choice
        options: ["true", "false"]
      do_transcript:
        description: "Send MP3 to Deepgram and create transcript/VTT"
        required: false
        default: "true"
        type: choice
        options: ["true", "false"]
      wp_marker:
        description: "opaque marker from WP for correlation"
        required: false
        default: ""
        type: string

permissions:
  contents: read

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    env:
      SPACE_URL: ${{ inputs.space_url }}
      TITLE_IN: ${{ inputs.title }}
      POST_ID: ${{ inputs.post_id }}
      GCS_PREFIX_IN: ${{ inputs.gcs_prefix }}
      MAKE_PUBLIC: ${{ inputs.make_public }}
      DO_TRANSCRIPT: ${{ inputs.do_transcript }}
      WP_MARKER: ${{ inputs.wp_marker }}
      # Secrets
      GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
      GCS_BUCKET: ${{ secrets.GCS_BUCKET }}
      WP_BASE_URL: ${{ secrets.WP_BASE_URL }}
      WP_USER: ${{ secrets.WP_USER }}
      WP_APP_PASSWORD: ${{ secrets.WP_APP_PASSWORD }}
      DEEPGRAM_API_KEY: ${{ secrets.DEEPGRAM_API_KEY }}
      # Vars (with sane defaults)
      PROXY_BASE: ${{ vars.PROXY_BASE }}
      PROXY_PREFIX: ${{ vars.PROXY_PREFIX }}

    steps:
      - name: Checkout (optional)
        uses: actions/checkout@v4

      - name: Set defaults & folders
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          : "${PROXY_BASE:=https://media.chbmp.org}"
          : "${PROXY_PREFIX:=}"
          : "${GCS_PREFIX_IN:=}"
          : "${TITLE_IN:=}"
          : "${POST_ID:=}"
          mkdir -p "$GITHUB_WORKSPACE/work" "$GITHUB_WORKSPACE/out"
          echo "workdir=$GITHUB_WORKSPACE/work"   >> $GITHUB_OUTPUT
          echo "outdir=$GITHUB_WORKSPACE/out"     >> $GITHUB_OUTPUT
          BASE="space-$(date +%Y%m%d-%H%M%S)-${GITHUB_RUN_ID}"
          echo "base=$BASE"                        >> $GITHUB_OUTPUT
          echo "proxy_base=$PROXY_BASE"           >> $GITHUB_OUTPUT
          echo "proxy_prefix=$PROXY_PREFIX"       >> $GITHUB_OUTPUT
          echo "gcs_prefix=$GCS_PREFIX_IN"        >> $GITHUB_OUTPUT
          echo "title_in=$TITLE_IN"               >> $GITHUB_OUTPUT
          echo "post_id=$POST_ID"                 >> $GITHUB_OUTPUT

      - name: Install deps (ffmpeg, jq, python, yt-dlp)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq python3 python3-pip
          python3 -m pip install --upgrade pip
          pip3 install yt-dlp

      - name: Auth & setup gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          export_default_credentials: true

      - name: Start — tell WP it’s processing
        if: env.WP_BASE_URL != ''
        env:
          WP_BASE_URL: ${{ env.WP_BASE_URL }}
          WP_USER: ${{ env.WP_USER }}
          WP_APP_PASSWORD: ${{ env.WP_APP_PASSWORD }}
        run: |
          set -euo pipefail
          if [[ -n "${POST_ID:-}" ]]; then
            curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
              -H 'Content-Type: application/json' \
              -X POST "${WP_BASE_URL}/wp-json/ss3k/v1/worker-status" \
              -d "{\"post_id\": ${POST_ID}, \"status\": \"processing\", \"run_id\":\"${GITHUB_RUN_ID}\", \"progress\": 1, \"message\": \"Worker started (queueing)\"}" >/dev/null
          fi

      - name: Download Space audio (yt-dlp or direct)
        id: grab
        env:
          WORKDIR: ${{ steps.prep.outputs.workdir }}
          SPACE_URL: ${{ env.SPACE_URL }}
        run: |
          set -euo pipefail
          cd "$WORKDIR"
          OUTFILE=""
          # If it's a direct file (ends with audio ext), just curl it
          if echo "$SPACE_URL" | grep -Eiq '\.(m4a|mp3|aac|mp4)(\?|$)'; then
            fname="$(basename "${SPACE_URL%%\?*}")"
            OUTFILE="$WORKDIR/${fname}"
            curl -L --fail -A "Mozilla/5.0" -o "$OUTFILE" "$SPACE_URL"
          else
            # Try yt-dlp (recorded Spaces are supported)
            yt-dlp -f ba -x --audio-format m4a \
              -o "%(title)s.%(ext)s" "$SPACE_URL" || yt-dlp -o "%(title)s.%(ext)s" "$SPACE_URL"
            # pick the largest m4a/mp4/aac we just got
            OUTFILE="$(ls -1t *.{m4a,mp4,aac,mp3} 2>/dev/null | head -n1 || true)"
            if [[ -z "$OUTFILE" ]]; then
              echo "No audio file downloaded."
              exit 2
            fi
            OUTFILE="$WORKDIR/$OUTFILE"
          fi
          echo "input_file=$OUTFILE" >> $GITHUB_OUTPUT
          echo "Got file: $OUTFILE"

      - name: Trim dead air + loudness-normalize → MP3
        id: audio
        env:
          IN: ${{ steps.grab.outputs.input_file }}
          OUTDIR: ${{ steps.prep.outputs.outdir }}
          BASE: ${{ steps.prep.outputs.base }}
        run: |
          set -euxo pipefail
          OUT_MP3="$OUTDIR/${BASE}.mp3"
          # Remove leading & trailing silence, then loudnorm to podcast-friendly target
          ffmpeg -hide_banner -y -i "$IN" -vn -ac 2 -ar 44100 \
            -af "silenceremove=start_periods=1:start_duration=0.5:start_threshold=-45dB,areverse,silenceremove=start_periods=1:start_duration=0.5:start_threshold=-45dB,areverse,loudnorm=I=-16:LRA=11:TP=-1.5" \
            -c:a libmp3lame -b:a 128k "$OUT_MP3"
          echo "out_mp3=$OUT_MP3" >> $GITHUB_OUTPUT

      - name: Upload MP3 to GCS
        id: uploadmp3
        env:
          OUT_MP3: ${{ steps.audio.outputs.out_mp3 }}
          GCS_BUCKET: ${{ env.GCS_BUCKET }}
          GCS_PREFIX: ${{ steps.prep.outputs.gcs_prefix }}
          BASE: ${{ steps.prep.outputs.base }}
          MAKE_PUBLIC: ${{ env.MAKE_PUBLIC }}
        run: |
          set -euo pipefail
          DEST="gs://${GCS_BUCKET}/${GCS_PREFIX}${BASE}.mp3"
          gsutil cp "$OUT_MP3" "$DEST"
          echo "gcs_url=gs://${GCS_BUCKET}/${GCS_PREFIX}${BASE}.mp3" >> $GITHUB_OUTPUT
          echo "public_url=https://storage.googleapis.com/${GCS_BUCKET}/${GCS_PREFIX}${BASE}.mp3" >> $GITHUB_OUTPUT
          # Public access (bucket-level IAM preferred; ACL may be blocked under UBLA)
          if [[ "${MAKE_PUBLIC}" == "true" ]]; then
            gsutil iam ch allUsers:objectViewer "gs://${GCS_BUCKET}" || true
          fi

      - name: Optional — tell WP after audio upload
        if: env.WP_BASE_URL != '' && env.POST_ID != ''
        env:
          WP_BASE_URL: ${{ env.WP_BASE_URL }}
          WP_USER: ${{ env.WP_USER }}
          WP_APP_PASSWORD: ${{ env.WP_APP_PASSWORD }}
        run: |
          set -euo pipefail
          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
            -H 'Content-Type: application/json' \
            -X POST "${WP_BASE_URL}/wp-json/ss3k/v1/worker-status" \
            -d "{\"post_id\": ${POST_ID}, \"status\": \"processing\", \"run_id\":\"${GITHUB_RUN_ID}\", \"progress\": 40, \"message\": \"Audio uploaded to GCS\"}" >/dev/null

      - name: Deepgram transcript + grouped VTT (if enabled)
        id: transcribe
        if: env.DO_TRANSCRIPT == 'true' && env.DEEPGRAM_API_KEY != ''
        env:
          OUTDIR: ${{ steps.prep.outputs.outdir }}
          OUT_MP3: ${{ steps.audio.outputs.out_mp3 }}
          DG_KEY: ${{ env.DEEPGRAM_API_KEY }}
        run: |
          set -euo pipefail
          DG_JSON="$OUTDIR/dg.json"
          TXT="$OUTDIR/${{ steps.prep.outputs.base }}.txt"
          VTT="$OUTDIR/${{ steps.prep.outputs.base }}.vtt"

          # Send to Deepgram (diarize + utterances)
          curl -sS -X POST 'https://api.deepgram.com/v1/listen?smart_format=true&model=nova-2&diarize=true&utterances=true' \
               -H "Authorization: Token ${DG_KEY}" \
               -H 'Content-Type: audio/mpeg' \
               --data-binary @"${OUT_MP3}" > "$DG_JSON"

          # Build grouped transcript + VTT with merged runs per speaker
          python3 - "$DG_JSON" "$TXT" "$VTT" << 'PY'
import json, sys

dg_path, txt_path, vtt_path = sys.argv[1], sys.argv[2], sys.argv[3]
with open(dg_path, 'r', encoding='utf-8') as f:
    data = json.load(f)

def secs_to_vtt(t):
    h = int(t//3600); t -= h*3600
    m = int(t//60);   s = t - m*60
    ms = int(round((s - int(s)) * 1000))
    return f"{h:02d}:{m:02d}:{int(s):02d}.{ms:03d}"

utts = []
if data.get("results",{}).get("utterances"):
    utts = data["results"]["utterances"]
elif data.get("results",{}).get("channels"):
    alts = data["results"]["channels"][0]["alternatives"][0]
    # fallback single blob
    utts = [{"speaker":0,"start":0.0,"end":alts.get("duration",0.0),"transcript":alts.get("transcript","").strip()}]

# group consecutive by speaker
paras = []
merged_cues = []
cur_s = None; cur_t=[]; start=None; end=None
for u in utts:
    sp = int(u.get("speaker", 0))
    t  = (u.get("transcript") or "").strip()
    s  = float(u.get("start") or 0.0)
    e  = float(u.get("end") or s)
    if not t: continue
    if cur_s is None:
        cur_s = sp; cur_t=[t]; start=s; end=e
    elif sp == cur_s:
        cur_t.append(t); end = e
    else:
        paras.append( (cur_s, " ".join(cur_t).strip()) )
        merged_cues.append( (start, end, cur_s, " ".join(cur_t).strip()) )
        cur_s = sp; cur_t=[t]; start=s; end=e
# flush
if cur_t:
    paras.append( (cur_s, " ".join(cur_t).strip()) )
    merged_cues.append( (start, end, cur_s, " ".join(cur_t).strip()) )

# write TXT
with open(txt_path, 'w', encoding='utf-8') as f:
    for sp, text in paras:
        f.write(f"Speaker {sp+1}: {text}\n\n")

# write WebVTT (merged cues)
with open(vtt_path, 'w', encoding='utf-8') as f:
    f.write("WEBVTT\n\n")
    for s, e, sp, text in merged_cues:
        f.write(f"{secs_to_vtt(s)} --> {secs_to_vtt(e)}\n")
        f.write(f"Speaker {sp+1}: {text}\n\n")
PY

          echo "tx_path=$TXT" >> $GITHUB_OUTPUT
          echo "vtt_path=$VTT" >> $GITHUB_OUTPUT

      - name: Upload VTT to GCS (if present)
        id: uploadvtt
        if: steps.transcribe.outputs.vtt_path != ''
        env:
          VTT: ${{ steps.transcribe.outputs.vtt_path }}
          GCS_BUCKET: ${{ env.GCS_BUCKET }}
          GCS_PREFIX: ${{ steps.prep.outputs.gcs_prefix }}
          BASE: ${{ steps.prep.outputs.base }}
          MAKE_PUBLIC: ${{ env.MAKE_PUBLIC }}
        run: |
          set -euo pipefail
          DEST="gs://${GCS_BUCKET}/${GCS_PREFIX}${BASE}.vtt"
          gsutil -h "Content-Type:text/vtt" cp "$VTT" "$DEST"
          if [[ "${MAKE_PUBLIC}" == "true" ]]; then
            gsutil iam ch allUsers:objectViewer "gs://${GCS_BUCKET}" || true
          fi
          echo "vtt_public=https://storage.googleapis.com/${GCS_BUCKET}/${GCS_PREFIX}${BASE}.vtt" >> $GITHUB_OUTPUT

      - name: Scrape /peek for attendees (best-effort)
        id: peek
        env:
          SPACE_URL: ${{ env.SPACE_URL }}
          OUTDIR: ${{ steps.prep.outputs.outdir }}
        run: |
          set -euo pipefail
          PEEK_HTML="$OUTDIR/peek.html"
          # try the "peek" page; not guaranteed to work without auth, but often enough for recorded spaces
          curl -sSL -A "Mozilla/5.0" "${SPACE_URL%/}/peek" -o "$PEEK_HTML" || true
          # parse best-effort with python; look for handles & roles in embedded json
          python3 - "$PEEK_HTML" "$OUTDIR/attendees.html" << 'PY'
import re, sys, json, html
inp, outp = sys.argv[1], sys.argv[2]
try:
    raw = open(inp, 'r', encoding='utf-8', errors='ignore').read()
except:
    raw = ""
# attempt to find embedded json
json_candidates = re.findall(r'\{.*\}', raw, flags=re.S)
host, cohosts, speakers = [], [], []
def add(lst, handle, name=None):
    handle = handle.strip('@')
    name = (name or '').strip()
    url = f"https://x.com/{handle}"
    label = f'{name} (@{handle})' if name else f'@{handle}'
    lst.append((url, label))
def uniq(lst):
    seen=set(); out=[]
    for u,l in lst:
        k=(u,l)
        if k in seen: continue
        seen.add(k); out.append((u,l))
    return out

# pass 1: look for obvious handles around role tokens
if raw:
    # very rough buckets if the html uses these words near anchors
    for m in re.findall(r'(?i)(Host|Co-?hosts?|Speakers?).{0,400}?href="https://x\.com/([A-Za-z0-9_]+)"[^>]*>([^<]{0,120})', raw):
        role, handle, name = m
        role = role.lower()
        if 'host' in role and 'co' not in role:
            add(host, handle, name)
        elif 'co' in role:
            add(cohosts, handle, name)
        else:
            add(speakers, handle, name)

# pass 2: generic unique anchors (fallback into "Speakers")
if not (host or cohosts or speakers):
    for handle,name in re.findall(r'href="https://x\.com/([A-Za-z0-9_]+)".{0,60}?>([^<]{0,120})', raw):
        add(speakers, handle, name)

host    = uniq(host)
cohosts = uniq(cohosts)
speakers= uniq(speakers)

html_out=[]
def block(title, items):
    if not items: return
    html_out.append(f'  <li><strong>{title}</strong>')
    html_out.append('    <ul>')
    for u,l in items:
        html_out.append(f'      <li><a href="{u}" target="_blank">{html.escape(l)}</a></li>')
    html_out.append('    </ul>')
    html_out.append('  </li>')

if host or cohosts or speakers:
    html_out_head=['<ul>']
    block("Host", host)
    block("Co-hosts", cohosts)
    block("Speakers", speakers)
    html_out_tail=['</ul>']
    open(outp,'w',encoding='utf-8').write("\n".join(html_out_head+html_out+html_out_tail))
else:
    open(outp,'w',encoding='utf-8').write("")
PY
          ATTH="$OUTDIR/attendees.html"
          if [[ -s "$ATTH" ]]; then
            echo "attendees_html_path=$ATTH" >> $GITHUB_OUTPUT
          else
            echo "attendees_html_path=" >> $GITHUB_OUTPUT
          fi

      - name: Register with WordPress
        id: register
        env:
          WP_BASE_URL: ${{ env.WP_BASE_URL }}
          WP_USER: ${{ env.WP_USER }}
          WP_APP_PASSWORD: ${{ env.WP_APP_PASSWORD }}
          BASE: ${{ steps.prep.outputs.base }}
          TITLE_IN: ${{ steps.prep.outputs.title_in }}
          POST_ID: ${{ steps.prep.outputs.post_id }}
          GCS_PUBLIC: ${{ steps.uploadmp3.outputs.public_url }}
          VTT_PUBLIC: ${{ steps.uploadvtt.outputs.vtt_public }}
          PROXY_BASE: ${{ steps.prep.outputs.proxy_base }}
          PROXY_PREFIX: ${{ steps.prep.outputs.proxy_prefix }}
          TX_PATH: ${{ steps.transcribe.outputs.tx_path }}
          ATTH: ${{ steps.peek.outputs.attendees_html_path }}
        run: |
          set -euo pipefail
          # compute proxy URL for MP3
          BN="$(basename "${GCS_PUBLIC}")"  # space-*.mp3
          PROXY_URL="${PROXY_BASE%/}/${PROXY_PREFIX#/}${BN}"
          # build JSON
          JFILE="$GITHUB_WORKSPACE/out/register.json"
          # read transcript if exists
          TX=""
          if [[ -n "${TX_PATH:-}" && -s "${TX_PATH:-}" ]]; then
            TX="$(cat "$TX_PATH")"
          fi
          # read attendees if exists
          ATT=""
          if [[ -n "${ATTH:-}" && -s "${ATTH:-}" ]]; then
            ATT="$(cat "$ATTH")"
          fi

          # prefer provided title or fall back to Space URL
          TITLE="${TITLE_IN:-Space: ${SPACE_URL}}"

          # compose payload
          jq -n \
            --arg title   "$TITLE" \
            --arg gcs     "$PROXY_URL" \
            --arg mime    "audio/mpeg" \
            --arg vtt     "${VTT_PUBLIC:-}" \
            --arg tx      "$TX" \
            --arg att     "$ATT" \
            --arg pid     "${POST_ID:-}" '
              {
                title: $title,
                gcs_url: $gcs,
                mime: $mime
              }
              + ( ( $vtt | select(length>0) ) as $v? | ( if $v? then { vtt_url: $v? } else {} end) )
              + ( ( $tx  | select(length>0) ) as $t? | ( if $t? then { transcript: $t? } else {} end) )
              + ( ( $att | select(length>0) ) as $a? | ( if $a? then { attendees_html: $a? } else {} end) )
              + ( ( $pid | tonumber? ) as $maybe | if $maybe then { post_id: $maybe } else {} end )
            ' > "$JFILE"

          echo "Register payload:"
          jq . "$JFILE"

          RESP="$GITHUB_WORKSPACE/out/register.out.json"
          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
            -H 'Content-Type: application/json' \
            -X POST "${WP_BASE_URL}/wp-json/ss3k/v1/register" \
            --data-binary @"$JFILE" > "$RESP"

          echo "WP response:"
          jq . "$RESP"

          # summarize
          PERMA="$(jq -r '.permalink // ""' "$RESP")"
          echo "permalink=$PERMA" >> $GITHUB_OUTPUT

      - name: Finish — tell WP it’s complete
        if: env.WP_BASE_URL != '' && env.POST_ID != ''
        env:
          WP_BASE_URL: ${{ env.WP_BASE_URL }}
          WP_USER: ${{ env.WP_USER }}
          WP_APP_PASSWORD: ${{ env.WP_APP_PASSWORD }}
          PERMA: ${{ steps.register.outputs.permalink }}
        run: |
          set -euo pipefail
          MSG="Worker finished. View: ${PERMA}"
          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
            -H 'Content-Type: application/json' \
            -X POST "${WP_BASE_URL}/wp-json/ss3k/v1/worker-status" \
            -d "{\"post_id\": ${POST_ID}, \"status\": \"complete\", \"message\": \"${MSG}\", \"run_id\": \"${GITHUB_RUN_ID}\", \"progress\": 100}" >/dev/null

      - name: Job summary
        if: always()
        env:
          SPACE_URL: ${{ env.SPACE_URL }}
          GCS_PUBLIC: ${{ steps.uploadmp3.outputs.public_url }}
          VTT_PUBLIC: ${{ steps.uploadvtt.outputs.vtt_public }}
          PERMA: ${{ steps.register.outputs.permalink }}
        run: |
          {
            echo "### Space Worker Summary"
            echo "- **Space URL:** ${SPACE_URL}"
            echo "- **GCS MP3:** ${GCS_PUBLIC}"
            if [[ -n "${VTT_PUBLIC:-}" ]]; then
              echo "- **GCS VTT:** ${VTT_PUBLIC}"
            fi
            echo "- **WP Post:** ${PERMA}"
          } >> "$GITHUB_STEP_SUMMARY"
