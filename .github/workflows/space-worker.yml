name: Space Worker

on:
  workflow_dispatch:
    inputs:
      space_url:
        description: X or Twitter Space URL
        required: false
        type: string
        default: ""
      post_id:
        description: Existing WordPress post ID optional
        required: false
        type: string
        default: ""
      title:
        description: Fallback post title optional
        required: false
        type: string
        default: ""
      gcs_prefix:
        description: GCS prefix default spaces YYYY/MM
        required: false
        type: string
        default: ""
      make_public:
        description: Make uploaded artifacts public
        required: false
        type: choice
        options: ["true","false"]
        default: "true"
      do_transcript:
        description: Generate transcript with Deepgram if crawler captions unavailable
        required: false
        type: choice
        options: ["true","false"]
        default: "true"
      mode:
        description: Limit processing to a specific area ('' = full)
        required: false
        type: choice
        options: ["", "transcript_only", "attendees_only", "watch"]
        default: ""
      existing_mp3_url:
        description: For transcript_only provide URL to existing MP3
        required: false
        type: string
        default: ""
      watch_users:
        description: Comma-separated X usernames to monitor (mode=watch)
        required: false
        type: string
        default: ""
      watch_duration_minutes:
        description: Minutes to monitor in watch mode (<= job timeout)
        required: false
        type: number
        default: 170
      # ---- Ads / Spots (optional) ----
      ads_enabled:
        description: Enable ad insertion
        required: false
        type: choice
        options: ["true","false"]
        default: "false"
      ad_urls:
        description: Comma-separated URLs to short ad MP3s (each used once)
        required: false
        type: string
        default: ""
      ad_first_minute:
        description: Earliest minute to allow first ad
        required: false
        type: number
        default: 10
      ad_min_gap_minutes:
        description: Minimum minutes between ad insertions
        required: false
        type: number
        default: 12
      ad_end_buffer_minutes:
        description: Keep last ad at least this many minutes before end
        required: false
        type: number
        default: 5

permissions:
  contents: read
  packages: read

env:
  GCP_SA_KEY:       ${{ secrets.GCP_SA_KEY       || vars.GCP_SA_KEY }}
  GCS_BUCKET:       ${{ secrets.GCS_BUCKET       || vars.GCS_BUCKET }}
  WP_BASE_URL:      ${{ secrets.WP_BASE_URL      || secrets.WP_URL || vars.WP_BASE_URL || vars.WP_URL }}
  WP_USER:          ${{ secrets.WP_USER          || vars.WP_USER }}
  WP_APP_PASSWORD:  ${{ secrets.WP_APP_PASSWORD  || vars.WP_APP_PASSWORD }}
  DEEPGRAM_API_KEY: ${{ secrets.DEEPGRAM_API_KEY || vars.DEEPGRAM_API_KEY }}
  TWITTER_AUTHORIZATION: ${{ secrets.TWITTER_AUTHORIZATION || secrets.X_BEARER     || vars.TWITTER_AUTHORIZATION || vars.X_BEARER }}
  TWITTER_AUTH_TOKEN:    ${{ secrets.TWITTER_AUTH_TOKEN    || secrets.X_AUTH_TOKEN || vars.TWITTER_AUTH_TOKEN    || vars.X_AUTH_TOKEN }}
  TWITTER_CSRF_TOKEN:    ${{ secrets.TWITTER_CSRF_TOKEN    || secrets.X_CSRF       || vars.TWITTER_CSRF_TOKEN    || vars.X_CSRF }}
  WORKDIR: ${{ github.workspace }}/work
  ARTDIR:  ${{ github.workspace }}/out

jobs:
  process:
    name: Process Space
    runs-on: ubuntu-latest
    timeout-minutes: 180
    concurrency:
      group: ${{ format('space-worker-{0}-{1}-{2}', github.ref, github.event.inputs.post_id != '' && github.event.inputs.post_id || github.run_id, github.event.inputs.watch_users) }}
      cancel-in-progress: false

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Notify WP — queued
        if: ${{ env.WP_BASE_URL != '' && env.WP_USER != '' && env.WP_APP_PASSWORD != '' && github.event.inputs.post_id != '' }}
        shell: bash
        run: |
          set -euo pipefail
          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
            -H "Content-Type: application/json" \
            -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/worker-status" \
            -d "$(jq -n --arg pid "${{ github.event.inputs.post_id }}" \
                       --arg status "queued" \
                       --arg msg "Workflow received and queued" \
                       --arg run "${{ github.run_id }}" \
                       --argjson progress 1 \
                       '{post_id: ($pid|tonumber), status:$status, message:$msg, run_id:$run, progress:$progress}')"

      - name: Install deps
        shell: bash
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends ffmpeg jq python3 python3-pip ca-certificates gnupg
          python3 -m pip install --upgrade pip
          python3 -m pip install --no-cache-dir yt-dlp
          echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] http://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
          curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
          sudo apt-get update && sudo apt-get install -y google-cloud-sdk
          echo "${{ github.token }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin || true

      - name: Validate config and prefixes
        id: cfg
        shell: bash
        run: |
          set -euxo pipefail
          test -n "${GCP_SA_KEY}" || { echo "GCP_SA_KEY missing"; exit 1; }
          test -n "${GCS_BUCKET}" || { echo "GCS_BUCKET missing"; exit 1; }
          mkdir -p "$WORKDIR" "$ARTDIR" "$ARTDIR/logs"
          PFX="$(echo "${{ github.event.inputs.gcs_prefix }}" | sed -E 's#^/*##; s#/*$##')"
          if [ -z "$PFX" ]; then PFX="spaces/$(date +%Y)/$(date +%m)"; fi
          echo "PREFIX=$PFX"                  >> "$GITHUB_ENV"
          echo "BUCKET_PREFIX=${PFX#spaces/}" >> "$GITHUB_ENV"

      - name: Derive Space ID and base
        id: ids
        shell: bash
        env:
          URL: ${{ github.event.inputs.space_url }}
        run: |
          set -euxo pipefail
          SID=""
          if [ -n "$URL" ]; then
            SID="$(echo "$URL" | sed -nE 's#^.*/i/spaces/([^/?#]+).*#\1#p')"
          fi
          [ -z "$SID" ] && SID="watch"
          BASE="space-$(date +%m-%d-%Y)-${SID}"
          echo "SPACE_ID=${SID}" >> "$GITHUB_ENV"
          echo "BASE=${BASE}"    >> "$GITHUB_ENV"
          echo "space_id=${SID}" >> "$GITHUB_OUTPUT"
          echo "base=${BASE}"    >> "$GITHUB_OUTPUT"

      - name: GCP auth
        shell: bash
        run: |
          set -euxo pipefail
          printf '%s' "${GCP_SA_KEY}" > "${HOME}/gcp-key.json"
          gcloud auth activate-service-account --key-file="${HOME}/gcp-key.json" >/dev/null

      - name: X preflight auth sanity check
        id: x_preflight
        shell: bash
        run: |
          set -euxo pipefail
          AUTH="${TWITTER_AUTHORIZATION:-}"
          AT="${TWITTER_AUTH_TOKEN:-}"
          CT="${TWITTER_CSRF_TOKEN:-}"

          if [ -n "$AUTH" ] && ! printf '%s' "$AUTH" | grep -q '^Bearer '; then AUTH=""; fi
          [ -n "${TWITTER_AUTHORIZATION:-}" ] && echo "::add-mask::${TWITTER_AUTHORIZATION}"
          [ -n "$AT" ] && echo "::add-mask::${AT}"
          [ -n "$CT" ] && echo "::add-mask::${CT}"

          OK=0; REASON="no_creds"
          [ -n "$AT" ] && [ -n "$CT" ] && OK=1 && REASON="cookie_ok" || true
          [ -n "$AUTH" ] && OK=1 && REASON="${REASON}_bearer_present" || true

          echo "ok=${OK}"         >> "$GITHUB_OUTPUT"
          echo "reason=${REASON}" >> "$GITHUB_OUTPUT"
          [ -n "$AUTH" ] && echo "TWITTER_AUTHORIZATION=$AUTH" >> "$GITHUB_ENV"

      - name: Run crawler (id or watch users)
        id: crawl
        if: ${{ steps.x_preflight.outputs.ok == '1' }}
        shell: bash
        env:
          SID: ${{ steps.ids.outputs.space_id }}
          WATCH_USERS: ${{ github.event.inputs.watch_users }}
          WATCH_MIN: ${{ github.event.inputs.watch_duration_minutes }}
        run: |
          set -euxo pipefail
          mkdir -p "${ARTDIR}" "${ARTDIR}/logs"
          docker pull ghcr.io/hitomarukonpaku/twspace-crawler:latest || true

          LOG_STD="${ARTDIR}/logs/crawler_${SID}.out.log"
          LOG_ERR="${ARTDIR}/logs/crawler_${SID}.err.log"

          set +e
          if [ "${{ github.event.inputs.mode }}" = "watch" ] && [ -n "${WATCH_USERS:-}" ]; then
            timeout "${WATCH_MIN}m" docker run --rm \
              -e TWITTER_AUTHORIZATION \
              -e TWITTER_AUTH_TOKEN \
              -e TWITTER_CSRF_TOKEN \
              -v "${ARTDIR}:/app/download" \
              -v "${ARTDIR}/logs:/app/logs" \
              ghcr.io/hitomarukonpaku/twspace-crawler:latest \
              --user "${WATCH_USERS}" > >(tee -a "$LOG_STD") 2> >(tee -a "$LOG_ERR" >&2)
          else
            timeout 20m docker run --rm \
              -e TWITTER_AUTHORIZATION \
              -e TWITTER_AUTH_TOKEN \
              -e TWITTER_CSRF_TOKEN \
              -v "${ARTDIR}:/app/download" \
              -v "${ARTDIR}/logs:/app/logs" \
              ghcr.io/hitomarukonpaku/twspace-crawler:latest \
              --id "${SID}" --force > >(tee -a "$LOG_STD") 2> >(tee -a "$LOG_ERR" >&2)
          fi
          RC=$?
          set -e
          echo "crawler_exit=${RC}"

          # Prefer crawler audio-like artifacts
          AUDIO_FILE="$(find "${ARTDIR}" -type f \( -iname '*.m4a' -o -iname '*.mp3' -o -iname '*.mp4' -o -iname '*.aac' -o -iname '*.webm' -o -iname '*.ogg' -o -iname '*.wav' -o -iname '*.ts' \) -printf '%T@ %p\n' | sort -nr | head -n1 | cut -d' ' -f2- || true)"
          if [ -n "${AUDIO_FILE:-}" ] && [ -f "${AUDIO_FILE}" ]; then
            echo "INPUT_FILE=${AUDIO_FILE}" >> "$GITHUB_ENV"
            echo "audio_file=${AUDIO_FILE}" >> "$GITHUB_OUTPUT"
          fi

          # Extract latest audioSpace JSON chunk from logs
          RAW="$(grep -hF 'getAudioSpaceById |' "$LOG_STD" "$LOG_ERR" | tail -n1 || true)"
          if [ -z "$RAW" ]; then
            RAW="$(grep -hF 'getAudioSpaceByRestId |' "$LOG_STD" "$LOG_ERR" | tail -n1 || true)"
          fi
          if [ -n "$RAW" ]; then
            printf '%s\n' "$RAW" > "${ARTDIR}/_as_line.txt"
            printf '%s\n' "$RAW" | awk -F'\\| ' '{print $NF}' > "${ARTDIR}/_as_line_after_pipe.txt" || true
            [ -s "${ARTDIR}/_as_line_after_pipe.txt" ] && cp "${ARTDIR}/_as_line_after_pipe.txt" "${ARTDIR}/_as_line.json" || true
          fi
          [ -s "${ARTDIR}/_as_line_after_pipe.txt" ] && echo "as_line=${ARTDIR}/_as_line_after_pipe.txt" >> "$GITHUB_OUTPUT" || true

          # If crawler already produced VTT, keep it
          CRAWLER_VTT="$(find "${ARTDIR}" -type f \( -iname '*.vtt' -o -iname '*.webvtt' \) -printf '%T@ %p\n' | sort -nr | head -n1 | cut -d' ' -f2- || true)"
          if [ -n "${CRAWLER_VTT:-}" ] && [ -s "${CRAWLER_VTT}" ]; then
            cp "${CRAWLER_VTT}" "${ARTDIR}/${BASE}.vtt"
            echo "VTT_PATH=${ARTDIR}/${BASE}.vtt" >> "$GITHUB_ENV"
          else
            # If captions JSONL exist, extract plaintext now; VTT conversion handled in a later step
            CC_JSONL="$(find "${ARTDIR}" -type f \( -iname '*cc.jsonl' -o -iname '*caption*.jsonl' \) -print | head -n1 || true)"
            if [ -n "${CC_JSONL:-}" ]; then
              docker run --rm -v "${ARTDIR}:/app/download" ghcr.io/hitomarukonpaku/twspace-crawler:latest cc e "/app/download${CC_JSONL#"${ARTDIR}"}" || true
            fi
          fi

      - name: Notify WP — processing audio
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.WP_BASE_URL != '' && env.WP_USER != '' && env.WP_APP_PASSWORD != '' && github.event.inputs.post_id != '' }}
        shell: bash
        run: |
          set -euo pipefail
          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
            -H "Content-Type: application/json" \
            -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/worker-status" \
            -d "$(jq -n --arg pid "${{ github.event.inputs.post_id }}" \
                         --arg status "processing" \
                         --arg msg "Processing audio" \
                         --arg run "${{ github.run_id }}" --argjson progress 10 \
                         '{post_id: ($pid|tonumber), status:$status, message:$msg, run_id:$run, progress:$progress}')"

      - name: Fallback download via yt-dlp
        if: ${{ github.event.inputs.mode != 'attendees_only' && (steps.crawl.outputs.audio_file == '' || steps.crawl.outcome != 'success') && github.event.inputs.existing_mp3_url == '' && github.event.inputs.space_url != '' }}
        shell: bash
        working-directory: ${{ env.WORKDIR }}
        env:
          URL: ${{ github.event.inputs.space_url }}
        run: |
          set -euxo pipefail
          yt-dlp -o "%(title)s.%(ext)s" -f "bestaudio/best" "$URL"
          IN="$(ls -S | head -n1 || true)"
          test -f "$IN" || { echo "No file downloaded"; exit 1; }
          echo "INPUT_FILE=$PWD/$IN" >> "$GITHUB_ENV"

      - name: Use provided MP3 for transcript only
        if: ${{ github.event.inputs.mode == 'transcript_only' && github.event.inputs.existing_mp3_url != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          curl -L "${{ github.event.inputs.existing_mp3_url }}" -o "${ARTDIR}/${BASE}.mp3"
          echo "INPUT_FILE=${ARTDIR}/${BASE}.mp3" >> "$GITHUB_ENV"

      - name: Trim head and tail silence
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.INPUT_FILE != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          TRIM_WAV="${WORKDIR}/trim_${{ github.run_id }}.wav"
          ffmpeg -hide_banner -y -i "$INPUT_FILE" \
            -af "silenceremove=start_periods=1:start_silence=1:start_threshold=-45dB:detection=peak,areverse,silenceremove=start_periods=1:start_silence=1:start_threshold=-45dB:detection=peak,areverse" \
            -ar 48000 -ac 2 -c:a pcm_s16le "$TRIM_WAV"
          echo "TRIM_WAV=${TRIM_WAV}" >> "$GITHUB_ENV"
          echo "AUDIO_IN=${TRIM_WAV}" >> "$GITHUB_ENV"

      - name: Enhance audio (denoise, de-click, gate, EQ)
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.AUDIO_IN != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          CLEAN_WAV="${WORKDIR}/clean_${{ github.run_id }}.wav"
          # afftdn: spectral de-noise; adeclick: reduce clicks; agate: light noise gate
          # highpass 80Hz (rumble), lowpass 12kHz (harshness)
          ffmpeg -hide_banner -y -i "$AUDIO_IN" \
            -af "afftdn=nr=12,adeclick,agate=threshold=0.02:ratio=2:attack=10:release=250,highpass=f=80,lowpass=f=12000,acompressor=threshold=-20dB:ratio=2:attack=20:release=250" \
            -ar 48000 -ac 2 -c:a pcm_s16le "$CLEAN_WAV"
          echo "CLEAN_WAV=${CLEAN_WAV}" >> "$GITHUB_ENV"
          # Use cleaned audio for subsequent steps
          echo "AUDIO_IN=${CLEAN_WAV}" >> "$GITHUB_ENV"

      - name: Detect long silences for ad placement
        id: silences
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.CLEAN_WAV != '' && github.event.inputs.ads_enabled == 'true' && github.event.inputs.ad_urls != '' }}
        shell: bash
        env:
          FIRST_MIN: ${{ github.event.inputs.ad_first_minute }}
          MIN_GAP:   ${{ github.event.inputs.ad_min_gap_minutes }}
          END_BUF:   ${{ github.event.inputs.ad_end_buffer_minutes }}
        run: |
          set -euxo pipefail
          # total duration
          DUR="$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$CLEAN_WAV" | awk '{printf("%.2f",$1)}')"
          echo "DURATION=${DUR}" >> "$GITHUB_ENV"

          # detect silences (>=1s), then choose those >=2.5s as candidates
          SLOG="${WORKDIR}/silence_${{ github.run_id }}.log"
          ffmpeg -hide_banner -i "$CLEAN_WAV" -af "silencedetect=n=-35dB:d=1" -f null - 2> "$SLOG" || true

          # Parse silence intervals and compute midpoints
          awk -v minlen=2.5 -v OFS='\t' '
            /silence_start:/ { s=$NF }
            /silence_end:/   { e=$NF; d=$(NF-2); if (d+0>=minlen) { mid=(s+e)/2; printf("%.2f\n", mid) } }
          ' "$SLOG" | sort -n > "${WORKDIR}/silence_midpoints.txt" || true

          # Filter to respect first minute, end buffer and min gap
          python3 - << 'PY'
import os, sys
def parse_list(p):
    if not os.path.exists(p): return []
    with open(p) as f: return [float(x.strip()) for x in f if x.strip()]
mids = parse_list(os.path.join(os.environ['WORKDIR'], 'silence_midpoints.txt'))
dur  = float(os.environ.get('DURATION','0') or 0)
first_min = float(os.environ.get('FIRST_MIN', '10')) * 60.0
min_gap   = float(os.environ.get('MIN_GAP', '12')) * 60.0
end_buf   = float(os.environ.get('END_BUF', '5'))  * 60.0
# Keep within [first_min, dur - end_buf]
cands = [t for t in mids if t>=first_min and t<=max(0.0, dur-end_buf)]
# Greedy spacing
picked=[]
for t in cands:
    if not picked or all(abs(t-p)>=min_gap for p in picked):
        picked.append(t)
# Write result
out = os.path.join(os.environ['WORKDIR'], 'ad_insert_points.txt')
with open(out,'w') as f:
    for t in picked:
        f.write(f"{t:.2f}\n")
print(f"picked={len(picked)}")
PY
          cat "${WORKDIR}/ad_insert_points.txt" || true

      - name: Download & prepare ad snippets (WAV)
        id: ads_prep
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.CLEAN_WAV != '' && github.event.inputs.ads_enabled == 'true' && github.event.inputs.ad_urls != '' }}
        shell: bash
        env:
          AD_URLS: ${{ github.event.inputs.ad_urls }}
        run: |
          set -euxo pipefail
          mkdir -p "${WORKDIR}/ads"
          # Normalize comma/space separated list
          echo "${AD_URLS}" | tr ',' '\n' | sed 's/^[[:space:]]*//; s/[[:space:]]*$//' | grep -v '^$' > "${WORKDIR}/ads/urls.txt"
          aidx=0
          while read -r URL; do
            aidx=$((aidx+1))
            curl -L "$URL" -o "${WORKDIR}/ads/ad_${aidx}.mp3"
            ffmpeg -hide_banner -y -i "${WORKDIR}/ads/ad_${aidx}.mp3" -ar 48000 -ac 2 -c:a pcm_s16le "${WORKDIR}/ads/ad_${aidx}.wav"
          done < "${WORKDIR}/ads/urls.txt"
          echo "ADS_COUNT=$aidx" >> "$GITHUB_ENV"

      - name: Assemble ads into cleaned audio (pre-normalize)
        id: ads_build
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.CLEAN_WAV != '' && github.event.inputs.ads_enabled == 'true' && github.event.inputs.ad_urls != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          DUR="${DURATION:-0}"
          [ "${DUR}" = "0" ] && DUR="$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$CLEAN_WAV" | awk '{printf("%.2f",$1)}')"
          # read desired insertion points
          mapfile -t PTS < "${WORKDIR}/ad_insert_points.txt" || true
          # Cap ad count to available points
          TOTAL_ADS="${ADS_COUNT:-0}"
          WANT=${TOTAL_ADS}
          [ "${#PTS[@]}" -lt "${WANT}" ] && WANT=${#PTS[@]}
          # If no silence points, fallback to evenly spaced schedule
          if [ "${WANT:-0}" -eq 0 ] && [ "${TOTAL_ADS:-0}" -gt 0 ]; then
            python3 - << 'PY'
import os
dur = float(os.environ.get('DURATION','0') or 0)
n   = int(os.environ.get('ADS_COUNT','0') or 0)
first_min = float(os.environ.get('ad_first_minute','10'))*60.0
end_buf   = float(os.environ.get('ad_end_buffer_minutes','5'))*60.0
if n>0 and dur> (first_min+end_buf+60):
    span = max(1.0, dur - first_min - end_buf)
    pts  = [first_min + (i+1)*span/(n+1) for i in range(n)]
else:
    pts=[]
open(os.path.join(os.environ['WORKDIR'],'ad_insert_points.txt'),'w').write('\n'.join(f"{t:.2f}" for t in pts))
print(f"fallback_points={len(pts)}")
PY
            mapfile -t PTS < "${WORKDIR}/ad_insert_points.txt" || true
            WANT=${#PTS[@]}
          fi

          # Build segment cuts: [0->pt1] ad1 [pt1->pt2] ad2 ... [ptN->end]
          mkdir -p "${WORKDIR}/segs"
          START=0
          IDX=0
          for pt in "${PTS[@]}"; do
            [ $IDX -ge ${ADS_COUNT:-0} ] && break
            OUT="${WORKDIR}/segs/seg_${IDX}.wav"
            ffmpeg -hide_banner -y -i "$CLEAN_WAV" -ss "$START" -to "$pt" -c:a pcm_s16le "$OUT"
            START="$pt"
            IDX=$((IDX+1))
          done
          # Tail
          ffmpeg -hide_banner -y -i "$CLEAN_WAV" -ss "$START" -to "$DUR" -c:a pcm_s16le "${WORKDIR}/segs/seg_${IDX}.wav"

          # Concat list alternating seg-i + ad-(i+1)
          LIST="${WORKDIR}/concat_with_ads.txt"
          : > "$LIST"
          i=0
          while [ $i -lt $IDX ]; do
            echo "file '${WORKDIR}/segs/seg_${i}.wav'" >> "$LIST"
            ai=$((i+1))
            [ -f "${WORKDIR}/ads/ad_${ai}.wav" ] && echo "file '${WORKDIR}/ads/ad_${ai}.wav'" >> "$LIST"
            i=$((i+1))
          done
          # add last tail
          echo "file '${WORKDIR}/segs/seg_${IDX}.wav'" >> "$LIST"

          CLEAN_ADS_WAV="${WORKDIR}/clean_ads_${{ github.run_id }}.wav"
          ffmpeg -hide_banner -y -f concat -safe 0 -i "$LIST" -c:a pcm_s16le "$CLEAN_ADS_WAV"
          echo "CLEAN_ADS_WAV=${CLEAN_ADS_WAV}" >> "$GITHUB_ENV"

      - name: Loudness normalize to MP3 (no-ads)
        id: norm_noads
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.CLEAN_WAV != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          PASS1_JSON="${WORKDIR}/loudnorm_noads_1.json"
          ffmpeg -hide_banner -y -i "$CLEAN_WAV" -af loudnorm=I=-16:TP=-1.5:LRA=11:print_format=json -f null - 2>"${WORKDIR}/noads_pass1.log" || true
          awk '/^{/{f=1} f{print} /}/{f=0}/' "${WORKDIR}/noads_pass1.log" > "$PASS1_JSON" || true
          NOADS_MP3="${ARTDIR}/${BASE}.mp3"
          if jq -e . "$PASS1_JSON" >/dev/null 2>&1; then
            I=$(jq -r '.input_i // "-16"'  "$PASS1_JSON"); TP=$(jq -r '.input_tp // "-1.5"' "$PASS1_JSON"); LRA=$(jq -r '.input_lra // "11"' "$PASS1_JSON"); TH=$(jq -r '.input_thresh // "-26"' "$PASS1_JSON")
            ffmpeg -hide_banner -y -i "$CLEAN_WAV" -af "loudnorm=I=-16:TP=-1.5:LRA=11:measured_I=$I:measured_TP=$TP:measured_LRA=$LRA:measured_thresh=$TH:linear=true,alimiter=limit=-1.5dB" -c:a libmp3lame -b:a 160k "$NOADS_MP3"
          else
            ffmpeg -hide_banner -y -i "$CLEAN_WAV" -af "loudnorm=I=-16:TP=-1.5:LRA=11,alimiter=limit=-1.5dB" -c:a libmp3lame -b:a 160k "$NOADS_MP3"
          fi
          echo "MP3_PATH=${NOADS_MP3}" >> "$GITHUB_ENV"
          echo "NOADS_MP3=${NOADS_MP3}" >> "$GITHUB_ENV"

      - name: Loudness normalize to MP3 (ads)
        id: norm_ads
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.CLEAN_ADS_WAV != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          PASS1_JSON="${WORKDIR}/loudnorm_ads_1.json"
          ffmpeg -hide_banner -y -i "$CLEAN_ADS_WAV" -af loudnorm=I=-16:TP=-1.5:LRA=11:print_format=json -f null - 2>"${WORKDIR}/ads_pass1.log" || true
          awk '/^{/{f=1} f{print} /}/{f=0}/' "${WORKDIR}/ads_pass1.log" > "$PASS1_JSON" || true
          ADS_MP3="${ARTDIR}/${BASE}.ads.mp3"
          if jq -e . "$PASS1_JSON" >/dev/null 2>&1; then
            I=$(jq -r '.input_i // "-16"'  "$PASS1_JSON"); TP=$(jq -r '.input_tp // "-1.5"' "$PASS1_JSON"); LRA=$(jq -r '.input_lra // "11"' "$PASS1_JSON"); TH=$(jq -r '.input_thresh // "-26"' "$PASS1_JSON")
            ffmpeg -hide_banner -y -i "$CLEAN_ADS_WAV" -af "loudnorm=I=-16:TP=-1.5:LRA=11:measured_I=$I:measured_TP=$TP:measured_LRA=$LRA:measured_thresh=$TH:linear=true,alimiter=limit=-1.5dB" -c:a libmp3lame -b:a 160k "$ADS_MP3"
          else
            ffmpeg -hide_banner -y -i "$CLEAN_ADS_WAV" -af "loudnorm=I=-16:TP=-1.5:LRA=11,alimiter=limit=-1.5dB" -c:a libmp3lame -b:a 160k "$ADS_MP3"
          fi
          echo "ADS_MP3=${ADS_MP3}" >> "$GITHUB_ENV"

      - name: Upload MP3 (no-ads) to GCS
        id: upload_mp3_noads
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.NOADS_MP3 != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          DEST="gs://${GCS_BUCKET}/${BUCKET_PREFIX}/${BASE}.mp3"
          RAW="https://storage.googleapis.com/${GCS_BUCKET}/${BUCKET_PREFIX}/${BASE}.mp3"
          PROXY="https://media.chbmp.org/${PREFIX}/${BASE}.mp3"
          gsutil -m cp "${NOADS_MP3}" "$DEST"
          if [ "${{ github.event.inputs.make_public }}" = "true" ]; then
            (gsutil acl ch -u AllUsers:R "$DEST" || gsutil iam ch allUsers:objectViewer "gs://${GCS_BUCKET}") || true
          fi
          echo "audio_noads_raw=${RAW}"     >> "$GITHUB_OUTPUT"
          echo "audio_noads_proxy=${PROXY}" >> "$GITHUB_OUTPUT"

      - name: Upload MP3 (ads) to GCS
        id: upload_mp3_ads
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.ADS_MP3 != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          DEST="gs://${GCS_BUCKET}/${BUCKET_PREFIX}/${BASE}.ads.mp3"
          RAW="https://storage.googleapis.com/${GCS_BUCKET}/${BUCKET_PREFIX}/${BASE}.ads.mp3"
          PROXY="https://media.chbmp.org/${PREFIX}/${BASE}.ads.mp3"
          gsutil -m cp "${ADS_MP3}" "$DEST"
          if [ "${{ github.event.inputs.make_public }}" = "true" ]; then
            (gsutil acl ch -u AllUsers:R "$DEST" || gsutil iam ch allUsers:objectViewer "gs://${GCS_BUCKET}") || true
          fi
          echo "audio_ads_raw=${RAW}"     >> "$GITHUB_OUTPUT"
          echo "audio_ads_proxy=${PROXY}" >> "$GITHUB_OUTPUT"

      - name: Prefer crawler captions if present
        id: crawl_cc
        if: ${{ github.event.inputs.mode != 'attendees_only' }}
        shell: bash
        run: |
          set -euxo pipefail
          [ -s "${ARTDIR}/${BASE}.vtt" ] && echo "VTT_PATH=${ARTDIR}/${BASE}.vtt" >> "$GITHUB_ENV" || true

      - name: Convert crawler JSONL captions to VTT
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.VTT_PATH == '' }}
        shell: bash
        run: |
          set -euxo pipefail
          CC_JSONL="$(find "${ARTDIR}" -type f \( -iname '*cc.jsonl' -o -iname '*caption*.jsonl' \) -print | head -n1 || true)"
          if [ -n "${CC_JSONL:-}" ] && [ -s "${CC_JSONL}" ]; then
            jq -s -r '
              def two(n): if n<10 then "0"+(n|tostring) else (n|tostring) end;
              def ms3(n): (1000 + (n%1000)|tostring)[1:4];
              def ts(ms):
                ( (ms/3600000)|floor ) as $h |
                ( (ms%3600000)/60000|floor ) as $m |
                ( (ms%60000)/1000|floor ) as $s |
                ( ms%1000 ) as $ms |
                ($h|tostring) + ":" + two($m) + ":" + two($s) + "." + ms3($ms);
              "WEBVTT", "",
              ( .[]
                | {s: (.startMs // .start_ms // .start // .offsetMs // 0),
                   d: (.durationMs // .duration_ms // .duration // .lenMs // 0),
                   t: (.text // .caption // .content // "")}
                | .e = (.s + .d)
                | select(.t != "")
                | (ts(.s) + " --> " + ts(.e)), (.t | gsub("\r";"")), ""
              )
            ' "$CC_JSONL" > "${ARTDIR}/${BASE}.vtt" || true
            [ -s "${ARTDIR}/${BASE}.vtt" ] && echo "VTT_PATH=${ARTDIR}/${BASE}.vtt" >> "$GITHUB_ENV" || true
          fi

      - name: Validate VTT (must contain header and cues)
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.VTT_PATH != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          if [ ! -s "$VTT_PATH" ]; then
            echo "VTT empty; clearing"
            echo "VTT_PATH=" >> "$GITHUB_ENV"
            exit 0
          fi
          HDR="$(head -n1 "$VTT_PATH" || true)"
          CUES="$(grep -c -- '-->' "$VTT_PATH" || true)"
          if [ "${HDR:-}" != "WEBVTT" ] || [ "${CUES:-0}" -lt 1 ]; then
            echo "Invalid VTT (hdr=${HDR:-none} cues=${CUES}); removing and clearing"
            rm -f "$VTT_PATH" || true
            echo "VTT_PATH=" >> "$GITHUB_ENV"
          fi

      - name: VTT via Deepgram (fallback)
        id: deepgram
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.VTT_PATH == '' && env.DEEPGRAM_API_KEY != '' && github.event.inputs.do_transcript == 'true' && env.NOADS_MP3 != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          curl -sS -X POST \
            -H "Authorization: Token ${DEEPGRAM_API_KEY}" \
            -H "Content-Type: audio/mpeg" \
            --data-binary @"${NOADS_MP3}" \
            "https://api.deepgram.com/v1/listen?model=nova-2&smart_format=true&punctuate=true&format=vtt" \
            -o "${ARTDIR}/${BASE}.vtt" || true
          [ -s "${ARTDIR}/${BASE}.vtt" ] && echo "VTT_PATH=${ARTDIR}/${BASE}.vtt" >> "$GITHUB_ENV" || true

      - name: Validate Deepgram VTT
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.VTT_PATH != '' && (steps.deepgram.outcome == 'success' || steps.deepgram.outcome == 'skipped') }}
        shell: bash
        run: |
          set -euxo pipefail
          if [ -f "$VTT_PATH" ]; then
            HDR="$(head -n1 "$VTT_PATH" || true)"
            CUES="$(grep -c -- '-->' "$VTT_PATH" || true)"
            if [ "${HDR:-}" != "WEBVTT" ] || [ "${CUES:-0}" -lt 1 ]; then
              echo "Deepgram VTT invalid or empty; clearing VTT_PATH"
              rm -f "$VTT_PATH" || true
              echo "VTT_PATH=" >> "$GITHUB_ENV"
            fi
          fi

      - name: Build transcript text (from CC JSONL or VTT)
        id: transcript
        if: ${{ github.event.inputs.mode != 'attendees_only' }}
        shell: bash
        run: |
          set -euxo pipefail
          OUT_TXT="${ARTDIR}/${BASE}.txt"
          rm -f "$OUT_TXT" || true

          # Prefer CC JSONL textual dump if available
          CC_JSONL="$(find "${ARTDIR}" -type f \( -iname '*cc.jsonl' -o -iname '*caption*.jsonl' \) -print | head -n1 || true)"
          if [ -n "${CC_JSONL:-}" ] && [ -s "${CC_JSONL}" ]; then
            jq -s -r '
              .[] | ( .text // .caption // .content // "" )
              | gsub("\r";"")
              | select(. != "")
            ' "$CC_JSONL" > "$OUT_TXT" || true
          fi

          # If still empty, derive from VTT
          if [ ! -s "$OUT_TXT" ] && [ -n "${VTT_PATH:-}" ] && [ -s "${VTT_PATH}" ]; then
            awk 'BEGIN{skip=0} !/-->/ && $0!="WEBVTT" && $0!~/^[[:space:]]*NOTE/ && $0!~/^[0-9]+$/ {print}' "$VTT_PATH" \
              | sed '/^[[:space:]]*$/d' > "$OUT_TXT" || true
          fi

          if [ -s "$OUT_TXT" ]; then
            echo "TRANSCRIPT_PATH=${OUT_TXT}" >> "$GITHUB_ENV"
          else
            echo "No transcript text generated."
          fi

      - name: Upload VTT to GCS
        id: upload_vtt
        if: ${{ github.event.inputs.mode != 'attendees_only' && env.VTT_PATH != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          DEST="gs://${GCS_BUCKET}/${BUCKET_PREFIX}/${BASE}.vtt"
          RAW="https://storage.googleapis.com/${GCS_BUCKET}/${BUCKET_PREFIX}/${BASE}.vtt"
          PROXY="https://media.chbmp.org/${PREFIX}/${BASE}.vtt"
          gsutil -m cp "${VTT_PATH}" "$DEST"
          if [ "${{ github.event.inputs.make_public }}" = "true" ]; then
            (gsutil acl ch -u AllUsers:R "$DEST" || gsutil iam ch allUsers:objectViewer "gs://${GCS_BUCKET}") || true
          fi
          echo "vtt_raw=${RAW}"     >> "$GITHUB_OUTPUT"
          echo "vtt_proxy=${PROXY}" >> "$GITHUB_OUTPUT"

      - name: Build attendees JSON & HTML (from crawler)
        id: attendees
        if: ${{ steps.crawl.outcome == 'success' && steps.crawl.outputs.as_line != '' }}
        shell: bash
        env:
          CAND: ${{ steps.crawl.outputs.as_line }}
        run: |
          set -euxo pipefail
          OUT_JSON="${ARTDIR}/attendees.json"
          OUT_HTML="${ARTDIR}/attendees.html"

          jq -r '
            def mkp:
              { handle: (.twitter_screen_name // .user_results?.result?.legacy?.screen_name),
                name:   (.display_name       // .user_results?.result?.legacy?.name)
              }
              | select(.handle!=null and .handle!="")
              | . + { url: ("https://x.com/" + .handle) };

            (.audioSpace // .) as $a
            | ($a.metadata?.creator_results?.result?.legacy?) as $h
            | ($h.screen_name // empty) as $H
            | {
                host:    ( if $H != "" then [ {handle:$H, name:($h.name // ""), url:("https://x.com/" + $H)} ] else [] end ),
                cohosts: ( ($a.participants?.admins   // []) | map(mkp) | map(select(.handle != $H)) | unique_by(.handle) ),
                speakers:( ($a.participants?.speakers // []) | map(mkp) | unique_by(.handle) )
              }
          ' "${CAND}" > "$OUT_JSON" || true

          if [ -s "$OUT_JSON" ]; then
            jq -r '
              def li: "  <li><a href=\"" + (.url//"#") + "\">" + ((.name // "") + " (@" + (.handle // "") + ")") + "</a></li>";
              def section(title; items):
                if (items|length) > 0
                then "<h3>" + title + "</h3>\n<ul>\n" + (items|map(li)|join("\n")) + "\n</ul>\n"
                else ""
                end;
              . as $d
              | section("Host"; $d.host)
              + section( (if ($d.cohosts|length)==1 then "Co-host" else "Co-hosts" end); $d.cohosts)
              + section("Speakers"; $d.speakers)
            ' "$OUT_JSON" > "$OUT_HTML"
            if grep -qi '<li><a ' "$OUT_HTML"; then
              echo "ATTN_HTML=${OUT_HTML}" >> "$GITHUB_ENV"
              echo "ATTENDEES_OK=1"       >> "$GITHUB_ENV"
            fi
          fi

      - name: Register assets in WP (finalize)
        if: ${{ env.WP_BASE_URL != '' && env.WP_USER != '' && env.WP_APP_PASSWORD != '' && github.event.inputs.post_id != '' && (steps.upload_mp3_noads.outputs.audio_noads_proxy != '' || steps.upload_mp3_noads.outputs.audio_noads_raw != '' || steps.upload_mp3_ads.outputs.audio_ads_proxy != '' || steps.upload_mp3_ads.outputs.audio_ads_raw != '') }}
        shell: bash
        env:
          PID:  ${{ github.event.inputs.post_id }}
          # Primary audio = no-ads; fall back to raw if proxy not there
          AUD:  ${{ steps.upload_mp3_noads.outputs.audio_noads_proxy || steps.upload_mp3_noads.outputs.audio_noads_raw }}
          VTTU: ${{ steps.upload_vtt.outputs.vtt_proxy   || steps.upload_vtt.outputs.vtt_raw }}
          TTL:  ${{ github.event.inputs.title }}
          ADSU: ${{ steps.upload_mp3_ads.outputs.audio_ads_proxy   || steps.upload_mp3_ads.outputs.audio_ads_raw }}
          NOADSU: ${{ steps.upload_mp3_noads.outputs.audio_noads_proxy || steps.upload_mp3_noads.outputs.audio_noads_raw }}
        run: |
          set -euo pipefail
          AT_HTML=""
          if [ -n "${ATTN_HTML:-}" ] && [ -s "${ATTN_HTML:-}" ]; then
            AT_HTML="$(cat "${ATTN_HTML}")"
          fi

          # Read transcript file if present
          TR_PATH="${TRANSCRIPT_PATH:-}"

          # Build base
          BODY_BASE="$(jq -n \
            --arg gcs   "${AUD}" \
            --arg mime  "audio/mpeg" \
            --arg pid   "${PID}" \
            --arg ttl   "${TTL}" \
            --arg vtt   "${VTTU}" \
            --arg ath   "${AT_HTML}" \
            --arg noads "${NOADSU}" \
            --arg ads   "${ADSU}" \
            '{
              gcs_url: $gcs,
              mime:    $mime,
              post_id: ($pid|tonumber),
              title:   $ttl
            }
            + (if ($vtt|length)>0 then {vtt_url:$vtt} else {} end)
            + (if ($ath|length)>0 then {attendees_html:$ath} else {} end)
            + {artifacts: {audio_noads_url: $noads}}
            + (if ($ads|length)>0 then {artifacts: {audio_noads_url: $noads, audio_ads_url: $ads}} else {} end)
          ')"

          # Attach transcript inline if generated
          if [ -n "$TR_PATH" ] && [ -s "$TR_PATH" ]; then
            jq -n --rawfile tr "$TR_PATH" \
              --slurpfile base <(printf '%s' "$BODY_BASE") \
              '$base[0] + {transcript: $tr}' > "${WORKDIR}/wp_register_body.json"
          else
            printf '%s' "$BODY_BASE" > "${WORKDIR}/wp_register_body.json"
          fi

          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
            -H "Content-Type: application/json" \
            -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/register" \
            -d "@${WORKDIR}/wp_register_body.json" | jq -r .

      - name: Patch WP — attendees only
        if: ${{ github.event.inputs.mode == 'attendees_only' && env.WP_BASE_URL != '' && env.WP_USER != '' && env.WP_APP_PASSWORD != '' && github.event.inputs.post_id != '' }}
        shell: bash
        run: |
          set -euo pipefail
          AT_HTML=""
          if [ -n "${ATTN_HTML:-}" ] && [ -s "${ATTN_HTML:-}" ]; then
            AT_HTML="$(cat "${ATTN_HTML}")"
          fi

          BODY="$(jq -n \
            --arg pid "${{ github.event.inputs.post_id }}" \
            --arg ath "${AT_HTML}" \
            '{post_id: ($pid|tonumber), status:"complete", progress:100}
             + (if ($ath|length)>0 then {attendees_html:$ath} else {} end)
          ')"

          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
            -H "Content-Type: application/json" \
            -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/patch-assets" \
            -d "$BODY" | jq -r .

      - name: Summary
        shell: bash
        env:
          SID: ${{ steps.ids.outputs.space_id }}
        run: |
          {
            echo "### Space Worker Summary"
            echo "- Space URL ${{ github.event.inputs.space_url }}"
            echo "- Space ID  ${SID}"
            echo "- Post ID   ${{ github.event.inputs.post_id }}"
            if [ -n "${{ steps.upload_mp3_noads.outputs.audio_noads_proxy }}" ]; then
              echo "- Audio (no-ads)  ${{ steps.upload_mp3_noads.outputs.audio_noads_proxy }}"
            elif [ -n "${{ steps.upload_mp3_noads.outputs.audio_noads_raw }}" ]; then
              echo "- Audio (no-ads)  ${{ steps.upload_mp3_noads.outputs.audio_noads_raw }}"
            fi
            if [ -n "${{ steps.upload_mp3_ads.outputs.audio_ads_proxy }}" ]; then
              echo "- Audio (ads)     ${{ steps.upload_mp3_ads.outputs.audio_ads_proxy }}"
            elif [ -n "${{ steps.upload_mp3_ads.outputs.audio_ads_raw }}" ]; then
              echo "- Audio (ads)     ${{ steps.upload_mp3_ads.outputs.audio_ads_raw }}"
            fi
            if [ -n "${{ steps.upload_vtt.outputs.vtt_proxy }}" ]; then
              echo "- VTT             ${{ steps.upload_vtt.outputs.vtt_proxy }}"
            elif [ -n "${{ steps.upload_vtt.outputs.vtt_raw }}" ]; then
              echo "- VTT             ${{ steps.upload_vtt.outputs.vtt_raw }}"
            else
              echo "- VTT             (none)"
            fi
            if [ -n "${TRANSCRIPT_PATH:-}" ] && [ -s "${TRANSCRIPT_PATH:-}" ]; then
              echo "- Transcript text: present (uploaded inline to WP)"
            else
              echo "- Transcript text: (none)"
            fi
            if [ "${ATTENDEES_OK:-0}" = "1" ]; then
              echo "- Attendees saved to WP (HTML)"
            else
              echo "- Attendees not extracted"
            fi
            echo "- Preflight ok=${{ steps.x_preflight.outputs.ok }} reason=${{ steps.x_preflight.outputs.reason }}"
            echo "- Mode      ${{ github.event.inputs.mode }}"
            if [ "${{ github.event.inputs.mode }}" = "watch" ]; then
              echo "- Watch users: ${{ github.event.inputs.watch_users }} (for ${{ github.event.inputs.watch_duration_minutes }}m)"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
