name: Space Worker

on:
  workflow_dispatch:
    inputs:
      space_url:
        description: X Twitter Space URL https://x.com/i/spaces/...
        required: true
        type: string
      title:
        description: Post title to use in WordPress (fallback if no post id)
        required: false
        type: string
        default: ""
      post_id:
        description: Existing WP post id to register or patch (optional)
        required: false
        type: string
        default: ""
      gcs_prefix:
        description: GCS prefix folder, e.g. spaces/2025/02 (empty => spaces/YYYY/MM)
        required: false
        type: string
        default: ""
      make_public:
        description: Set GCS objects to public
        required: false
        type: choice
        options: ["true", "false"]
        default: "true"
      do_transcript:
        description: Generate diarized transcript & VTT via Deepgram (used if crawler captions unavailable)
        required: false
        type: choice
        options: ["true", "false"]
        default: "true"
      wp_marker:
        description: Opaque marker from WP (optional)
        required: false
        type: string
        default: ""
      space_id:
        description: Space ID (e.g., 1kvJpyzZOOkxE) — auto parsed from URL if blank
        required: false
        type: string
        default: ""
      mode:
        description: Optional targeted mode
        required: false
        type: choice
        options: ["", "transcript_only", "attendees_only"]
        default: ""
      existing_mp3_url:
        description: (transcript_only) URL of the already-encoded MP3
        required: false
        type: string
        default: ""

permissions:
  contents: read
  packages: read

concurrency:
  group: ${{ format('space-worker-{0}-{1}', github.ref, inputs.post_id != '' && inputs.post_id || github.run_id) }}
  cancel-in-progress: false

env:
  GCP_SA_KEY:       ${{ secrets.GCP_SA_KEY       || vars.GCP_SA_KEY }}
  GCS_BUCKET:       ${{ secrets.GCS_BUCKET       || vars.GCS_BUCKET }}
  WP_BASE_URL:      ${{ secrets.WP_BASE_URL      || secrets.WP_URL || vars.WP_BASE_URL || vars.WP_URL }}
  WP_USER:          ${{ secrets.WP_USER          || vars.WP_USER }}
  WP_APP_PASSWORD:  ${{ secrets.WP_APP_PASSWORD  || vars.WP_APP_PASSWORD }}
  DEEPGRAM_API_KEY: ${{ secrets.DEEPGRAM_API_KEY || vars.DEEPGRAM_API_KEY }}

  # X/Twitter creds (web API)
  TWITTER_AUTHORIZATION: ${{ secrets.TWITTER_AUTHORIZATION || secrets.X_BEARER || vars.TWITTER_AUTHORIZATION || vars.X_BEARER }}
  TWITTER_AUTH_TOKEN:    ${{ secrets.TWITTER_AUTH_TOKEN    || secrets.X_AUTH_TOKEN || vars.TWITTER_AUTH_TOKEN || vars.X_AUTH_TOKEN }}
  TWITTER_CSRF_TOKEN:    ${{ secrets.TWITTER_CSRF_TOKEN    || secrets.X_CSRF       || vars.TWITTER_CSRF_TOKEN || vars.X_CSRF }}

  WORKDIR: ${{ github.workspace }}/work
  ARTDIR:  ${{ github.workspace }}/out

jobs:
  run:
    name: Process Space
    runs-on: ubuntu-latest
    timeout-minutes: 180

    steps:
      - name: Start ping WP — queued
        if: ${{ env.WP_BASE_URL != '' && env.WP_USER != '' && env.WP_APP_PASSWORD != '' && inputs.post_id != '' }}
        shell: bash
        run: |
          set -euo pipefail
          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
            -H "Content-Type: application/json" \
            -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/worker-status" \
            -d "$(jq -n --arg pid "${{ inputs.post_id }}" --arg status "queued" \
                       --arg msg "Workflow received and queued" \
                       --arg run "${{ github.run_id }}" --argjson progress 1 \
                       '{post_id: ($pid|tonumber), status:$status, message:$msg, run_id:$run, progress:$progress}')"

      - name: Install deps (ffmpeg, jq, yt-dlp, gcloud)
        shell: bash
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends ffmpeg jq python3 python3-pip ca-certificates gnupg
          python3 -m pip install --upgrade pip
          python3 -m pip install --no-cache-dir yt-dlp
          echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] http://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
          curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
          sudo apt-get update && sudo apt-get install -y google-cloud-sdk

      - name: Validate env & prepare folders
        id: cfg
        shell: bash
        run: |
          set -euo pipefail
          test -n "${GCP_SA_KEY}" || { echo "GCP_SA_KEY missing"; exit 1; }
          test -n "${GCS_BUCKET}" || { echo "GCS_BUCKET missing"; exit 1; }
          mkdir -p "$WORKDIR" "$ARTDIR" "$ARTDIR/logs"
          PFX_RAW="${{ inputs.gcs_prefix }}"
          PFX="$(echo "$PFX_RAW" | sed -E 's#^/*##; s#/*$##')"
          if [ -z "$PFX" ]; then
            PFX="spaces/$(date +%Y)/$(date +%m)"
          fi
          echo "prefix=${PFX}" >> "$GITHUB_OUTPUT"
          echo "PREFIX=${PFX}" >> "$GITHUB_ENV"
          echo "MAKE_PUBLIC=${{ inputs.make_public }}" >> "$GITHUB_ENV"
          echo "DO_TRANSCRIPT=${{ inputs.do_transcript }}" >> "$GITHUB_ENV"
          echo "MODE=${{ inputs.mode }}" >> "$GITHUB_ENV"

      - name: Derive Space ID from URL (or use provided)
        id: ids
        shell: bash
        run: |
          set -euo pipefail
          SPACE_ID="${{ inputs.space_id }}"
          if [ -z "$SPACE_ID" ]; then
            # parse last token or /i/spaces/<id>
            PATHPART="$(echo "${{ inputs.space_url }}" | awk -F'/' '{print $NF}')"
            if echo "${{ inputs.space_url }}" | grep -qE '/i/spaces/'; then
              SPACE_ID="$(echo "${{ inputs.space_url }}" | sed -E 's#.*?/i/spaces/([^/?#]+).*#\1#')"
            elif echo "$PATHPART" | grep -qE '^[0-9A-Za-z]+$'; then
              SPACE_ID="$PATHPART"
            fi
          fi
          test -n "$SPACE_ID" || { echo "Could not derive Space ID"; exit 1; }
          echo "space_id=$SPACE_ID" >> "$GITHUB_OUTPUT"
          echo "SPACE_ID=$SPACE_ID"  >> "$GITHUB_ENV"

      - name: Auth gcloud & set bucket base
        id: gcloud
        shell: bash
        run: |
          set -euo pipefail
          echo "${GCP_SA_KEY}" > "$WORKDIR/sa.json"
          gcloud auth activate-service-account --key-file="$WORKDIR/sa.json" >/dev/null
          # Compute public base URL helper
          echo "PUBLIC_BASE=https://storage.googleapis.com/${GCS_BUCKET}" >> "$GITHUB_ENV"
          echo "GS_PREFIX=gs://${GCS_BUCKET}/${PREFIX}" >> "$GITHUB_ENV"

      - name: Ping WP — processing (peek metadata/participants)
        if: ${{ env.WP_BASE_URL != '' && env.WP_USER != '' && env.WP_APP_PASSWORD != '' && inputs.post_id != '' }}
        shell: bash
        run: |
          set -euo pipefail
          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" -H "Content-Type: application/json" \
            -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/worker-status" \
            -d "$(jq -n --arg pid "${{ inputs.post_id }}" --arg status "processing" --arg msg "Fetching Space metadata / participants" --argjson progress 5 \
                   '{post_id: ($pid|tonumber), status:$status, message:$msg, progress:$progress, run_id:"'${{ github.run_id }}'"}')"

      - name: Fetch participants (public peek → auth API → guest API)
        id: peek
        shell: bash
        run: |
          set -euo pipefail
          set -x
          SP="$SPACE_ID"
          COMMON_HEADERS=(-H 'accept: application/json, text/plain, */*' -H 'user-agent: Mozilla/5.0 (SpaceSaver/2.8)' -H 'referer: https://x.com/' -H 'accept-language: en-US,en;q=0.8')
          OUTJSON="$WORKDIR/participants.json"
          METAJSON="$WORKDIR/peek.json"
          SRC="none"

          # Attempt 1: public peek
          for U in "https://x.com/i/spaces/$SP/peek" "https://twitter.com/i/spaces/$SP/peek"; do
            if curl -fsS "${COMMON_HEADERS[@]}" "$U" -o "$METAJSON"; then
              if jq -e 'type=="object"' "$METAJSON" >/dev/null 2>&1; then
                SRC="public_peek"
                break
              fi
            fi
          done

          # Attempt 2: full auth API (bearer + cookie + csrf)
          if [ "$SRC" = "none" ] && [ -n "${TWITTER_AUTHORIZATION:-}" ] && [ -n "${TWITTER_AUTH_TOKEN:-}" ] && [ -n "${TWITTER_CSRF_TOKEN:-}" ]; then
            API="https://x.com/i/api/spaces/$SP/participants"
            if curl -fsS "${COMMON_HEADERS[@]}" \
              -H "authorization: Bearer $(echo "$TWITTER_AUTHORIZATION" | sed -E 's/^Bearer +//I')" \
              -H "x-csrf-token: ${TWITTER_CSRF_TOKEN}" \
              -H "cookie: auth_token=${TWITTER_AUTH_TOKEN}; ct0=${TWITTER_CSRF_TOKEN}" \
              "$API" -o "$OUTJSON"; then
              if jq -e 'type=="object"' "$OUTJSON" >/dev/null 2>&1; then
                SRC="auth_api"
              fi
            fi
          fi

          # Attempt 3: guest API (bearer + guest token)
          if [ "$SRC" = "none" ] && [ -n "${TWITTER_AUTHORIZATION:-}" ]; then
            GUEST="$(curl -fsS "${COMMON_HEADERS[@]}" \
              -H "authorization: Bearer $(echo "$TWITTER_AUTHORIZATION" | sed -E 's/^Bearer +//I')" \
              -H 'content-type: application/json' \
              -X POST 'https://api.twitter.com/1.1/guest/activate.json' -d '{}' | jq -r '.guest_token // empty')"
            if [ -n "$GUEST" ]; then
              API="https://x.com/i/api/spaces/$SP/participants"
              if curl -fsS "${COMMON_HEADERS[@]}" \
                -H "authorization: Bearer $(echo "$TWITTER_AUTHORIZATION" | sed -E 's/^Bearer +//I')" \
                -H "x-guest-token: $GUEST" \
                "$API" -o "$OUTJSON"; then
                if jq -e 'type=="object"' "$OUTJSON" >/dev/null 2>&1; then
                  SRC="guest_api"
                fi
              fi
            fi
          fi

          # Normalize a single JSON that includes metadata & participants
          # Prefer OUTJSON if we have it; otherwise METAJSON
          if [ -s "$OUTJSON" ]; then
            cp "$OUTJSON" "$WORKDIR/raw_participants.json"
          else
            # extract participant-like sections if present (some peek payloads embed)
            cp "$METAJSON" "$WORKDIR/raw_participants.json" || true
          fi

          echo "source=$SRC" >> "$GITHUB_OUTPUT"

      - name: Build attendees grouped + HTML (and detect space timestamp)
        id: attendees
        shell: bash
        run: |
          set -euo pipefail
          RAW="$WORKDIR/raw_participants.json"
          OUT_JSON="$ARTDIR/attendees_grouped.json"
          OUT_HTML="$ARTDIR/attendees.html"
          # Extract admins/speakers from multiple shapes:
          # -> /i/api shape: {participants:{admins:[], speakers:[]}}
          # -> flattened: {admins:[], speakers:[]}
          # Fallbacks tolerate missing arrays.

          jq -n \
            --slurpfile data "$RAW" '
              def pick(v;k): if (v|has(k)) then v[k] else [] end;
              def ppl(v):
                if (v|type)=="object" then
                  if (v|has("participants")) then
                    {"admins": pick(v["participants"];"admins"),
                     "speakers": pick(v["participants"];"speakers")}
                  else
                    {"admins": pick(v;"admins"), "speakers": pick(v;"speakers")}
                  end
                else {"admins": [], "speakers": []} end;

              # choose first object in slurp that is a map
              ( ($data|first) // {} ) as $root
              | (ppl($root)) as $p
              | {
                  admins: ($p.admins // []),
                  speakers: ($p.speakers // []),
                  # best-effort metadata timestamps (various shapes)
                  started_at: (
                    ($root.data.audioSpace.metadata.started_at? // $root.started_at? // $root.metadata.started_at? // null)
                  )
                }
            ' > "$WORKDIR/participants_norm.json"

          # Deduplicate + normalize fields we need (name, handle, url, role)
          jq '
            def normu(u):
              { name:   (u.display_name // u.name // ""),
                handle: (u.screen_name  // u.username // ""),
                role:   ((u.role // "") | ascii_downcase),
                url:    ( (if (u.screen_name // u.username // "")=="" then "" else "https://x.com/" + (u.screen_name // u.username) end) )
              };

            . as $R
            | .admins  as $A
            | .speakers as $S
            | {
                started_at: $R.started_at,
                host: (
                  [ $A[] | normu(.) ] 
                  | map(select(.handle!=""))
                  | map(if .role=="host" then . else . end)
                  | unique_by(.handle)
                  | (if length==0 then [] else ( [.[0]] ) end) # pick first admin as host if no explicit host
                ),
                cohosts: (
                  [ $A[] | normu(.) ]
                  | map(select(.handle!=""))
                  | map(select(.role=="cohost" or .role=="co-host" or .role=="co_host" or .role==""))
                  | unique_by(.handle)
                  | (if length>0 then (if .[0].handle == ( (.[0]//{}).handle ) then . else . end) else [] end)
                ),
                speakers: (
                  [ $S[] | normu(.) ]
                  | map(select(.handle!=""))
                  | unique_by(.handle)
                )
              }
          ' "$WORKDIR/participants_norm.json" > "$OUT_JSON"

          # Build attendees HTML <ul>Host/Co-hosts/Speakers</ul>
          build_li() {
            local name="$1" handle="$2" url="$3"
            if [ -n "$name" ]; then
              printf '<li><a href="%s" target="_blank" rel="noopener">%s (@%s)</a></li>\n' "$url" "$name" "$handle"
            else
              printf '<li><a href="%s" target="_blank" rel="noopener">@%s</a></li>\n' "$url" "$handle"
            fi
          }

          {
            echo '<ul>'
            # Host
            if jq -e '.host|length>0' "$OUT_JSON" >/dev/null 2>&1; then
              echo '<li><strong>Host</strong><ul>'
              jq -r '.host[] | @tsv "\(.name)\t\(.handle)\t\(.url)"' "$OUT_JSON" | while IFS=$'\t' read -r n h u; do
                build_li "$n" "$h" "$u"
              done
              echo '</ul></li>'
            fi
            # Co-hosts
            if jq -e '.cohosts|length>0' "$OUT_JSON" >/dev/null 2>&1; then
              echo '<li><strong>Co-hosts</strong><ul>'
              jq -r '.cohosts[] | @tsv "\(.name)\t\(.handle)\t\(.url)"' "$OUT_JSON" | while IFS=$'\t' read -r n h u; do
                build_li "$n" "$h" "$u"
              done
              echo '</ul></li>'
            fi
            # Speakers
            if jq -e '.speakers|length>0' "$OUT_JSON" >/dev/null 2>&1; then
              echo '<li><strong>Speakers</strong><ul>'
              jq -r '.speakers[] | @tsv "\(.name)\t\(.handle)\t\(.url)"' "$OUT_JSON" | while IFS=$'\t' read -r n h u; do
                build_li "$n" "$h" "$u"
              done
              echo '</ul></li>'
            fi
            echo '</ul>'
          } > "$OUT_HTML"

          # Extract best timestamp (ISO8601) if present; fallback to now
          SPACE_ISO="$(jq -r '.started_at // empty' "$ARTDIR/attendees_grouped.json")"
          if [ -n "$SPACE_ISO" ]; then
            # Normalize to YYYY-mm-dd for naming
            SPACE_TS="$(date -d "$SPACE_ISO" +%s 2>/dev/null || true)"
          fi
          if [ -z "${SPACE_TS:-}" ]; then
            SPACE_TS="$(date +%s)"
          fi
          echo "space_ts=$SPACE_TS" >> "$GITHUB_OUTPUT"
          echo "SPACE_TS=$SPACE_TS"  >> "$GITHUB_ENV"

          # Progress ping
          if [ -n "${WP_BASE_URL:-}" ] && [ -n "${WP_USER:-}" ] && [ -n "${WP_APP_PASSWORD:-}" ] && [ -n "${{ inputs.post_id }}" ]; then
            curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" -H "Content-Type: application/json" \
              -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/worker-status" \
              -d "$(jq -n --arg pid "${{ inputs.post_id }}" --arg status "processing" --arg msg "Attendees scraped and HTML assembled" --argjson progress 15 \
                     --arg space_date "$SPACE_TS" \
                     '{post_id: ($pid|tonumber), status:$status, message:$msg, progress:$progress, run_id:"'${{ github.run_id }}'", space_date:$space_date}')"
          fi

      - name: Compute basenames (use Space timestamp when available)
        id: names
        shell: bash
        run: |
          set -euo pipefail
          TS="$SPACE_TS"
          MM="$(date -u -d "@$TS" +%m)"
          DD="$(date -u -d "@$TS" +%d)"
          YY="$(date -u -d "@$TS" +%Y)"
          BASENAME="space-${MM}-${DD}-${YY}-${SPACE_ID}"
          echo "BASENAME=${BASENAME}" >> "$GITHUB_ENV"
          echo "mp3_name=${BASENAME}.mp3" >> "$GITHUB_OUTPUT"
          echo "vtt_name=${BASENAME}.vtt" >> "$GITHUB_OUTPUT"
          echo "att_html_name=${BASENAME}-attendees.html" >> "$GITHUB_OUTPUT"
          echo "att_json_name=${BASENAME}-attendees.json" >> "$GITHUB_OUTPUT"

      - name: Upload attendees artifacts to GCS
        id: up_att
        shell: bash
        run: |
          set -euo pipefail
          DEST_DIR="${GS_PREFIX}"
          ATT_HTML="$ARTDIR/attendees.html"
          ATT_JSON="$ARTDIR/attendees_grouped.json"
          HTML_NAME="${{ steps.names.outputs.att_html_name }}"
          JSON_NAME="${{ steps.names.outputs.att_json_name }}"
          # Ensure prefix exists (gsutil will create objects on upload)
          gsutil -m cp -Z -a public-read "$ATT_HTML" "${DEST_DIR}/${HTML_NAME}"
          gsutil -m cp -Z -a public-read "$ATT_JSON" "${DEST_DIR}/${JSON_NAME}"
          echo "att_html_url=${PUBLIC_BASE}/${PREFIX}/${HTML_NAME}" >> "$GITHUB_OUTPUT"
          echo "att_json_url=${PUBLIC_BASE}/${PREFIX}/${JSON_NAME}" >> "$GITHUB_OUTPUT"

      - name: Early-patch attendees (attendees_only or while full run continues)
        if: ${{ env.WP_BASE_URL != '' && env.WP_USER != '' && env.WP_APP_PASSWORD != '' && inputs.post_id != '' }}
        shell: bash
        run: |
          set -euo pipefail
          # Always patch early so the editor sees attendees quickly
          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" -H "Content-Type: application/json" \
            -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/patch-assets" \
            -d "$(jq -n \
                  --arg pid "${{ inputs.post_id }}" \
                  --arg attendees_html "$(cat "$ARTDIR/attendees.html")" \
                  --argjson attendees_json "$(cat "$ARTDIR/attendees_grouped.json")" \
                  --arg att_html_url "${{ steps.up_att.outputs.att_html_url }}" \
                  --arg att_json_url "${{ steps.up_att.outputs.att_json_url }}" \
                  --arg source "${{ steps.peek.outputs.source }}" \
                  --arg space_date "${SPACE_TS}" \
                  --arg status "processing" \
                  --arg msg "Attendees saved (HTML + JSON). Continuing." \
                  --argjson progress 20 \
                  '{
                    post_id: ($pid|tonumber),
                    attendees_html: $attendees_html,
                    attendees_json: $attendees_json,
                    artifacts: { attendees_html_url: $att_html_url, attendees_json_url: $att_json_url, attendees_source: $source },
                    space_date: $space_date,
                    status: $status,
                    message: $msg,
                    progress: $progress
                  }')"

      - name: Short-circuit (attendees_only mode)
        if: ${{ env.MODE == 'attendees_only' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Mode attendees_only — finishing after attendees patch."
          exit 0

      - name: Download audio (skip if transcript_only with existing_mp3_url)
        id: dl
        if: ${{ env.MODE != 'transcript_only' }}
        shell: bash
        run: |
          set -euo pipefail
          AUD_RAW="$WORKDIR/raw.m4a"
          # Retry helper
          run_yt() {
            yt-dlp -f 'ba/best' -x --audio-format m4a --no-playlist --geo-bypass \
                   --no-progress --restrict-filenames -o "$WORKDIR/%(title)s.%(ext)s" \
                   -- "$SPACE_ID" 2>&1 || yt-dlp -f 'ba/best' -x --audio-format m4a \
                   --no-playlist --geo-bypass --no-progress --restrict-filenames \
                   -o "$WORKDIR/%(title)s.%(ext)s" -- "$SPACE_ID"
          }
          # yt-dlp can accept raw Space ID in many cases; if not, pass full URL
          if ! run_yt; then
            yt-dlp -f 'ba/best' -x --audio-format m4a --no-playlist --geo-bypass \
                   --no-progress --restrict-filenames -o "$WORKDIR/%(title)s.%(ext)s" \
                   -- "${{ inputs.space_url }}"
          fi
          # pick the newest m4a
          FOUND="$(ls -1t "$WORKDIR"/*.m4a 2>/dev/null | head -n1 || true)"
          test -n "$FOUND" || { echo "Failed to download Space audio"; exit 1; }
          cp "$FOUND" "$AUD_RAW"
          echo "raw_audio=$AUD_RAW" >> "$GITHUB_OUTPUT"

      - name: Transcode & loudnorm to MP3
        id: enc
        if: ${{ env.MODE != 'transcript_only' }}
        shell: bash
        run: |
          set -euo pipefail
          IN="$WORKDIR/raw.m4a"
          OUT="$ARTDIR/audio.mp3"
          ffmpeg -hide_banner -loglevel error -y -i "$IN" \
            -vn -acodec libmp3lame -b:a 128k \
            -af loudnorm=I=-16:TP=-1.5:LRA=11:print_format=summary \
            "$OUT"
          echo "mp3_path=$OUT" >> "$GITHUB_OUTPUT"

      - name: Upload MP3 to GCS
        id: up_mp3
        if: ${{ env.MODE != 'transcript_only' }}
        shell: bash
        run: |
          set -euo pipefail
          NAME="${{ steps.names.outputs.mp3_name }}"
          gsutil -m cp -a public-read "$ARTDIR/audio.mp3" "${GS_PREFIX}/${NAME}"
          echo "mp3_url=${PUBLIC_BASE}/${PREFIX}/${NAME}" >> "$GITHUB_OUTPUT"

      - name: Transcript & VTT (Deepgram) — skip if disabled or no key
        id: dg
        if: ${{ (env.DO_TRANSCRIPT == 'true') && (env.MODE != 'attendees_only') && (env.DEEPGRAM_API_KEY != '') }}
        shell: bash
        run: |
          set -euo pipefail
          # Resolve MP3 URL to feed Deepgram
          MP3_URL_INPUT="${{ steps.up_mp3.outputs.mp3_url }}"
          if [ -z "$MP3_URL_INPUT" ] && [ "${MODE}" = "transcript_only" ] && [ -n "${{ inputs.existing_mp3_url }}" ]; then
            MP3_URL_INPUT="${{ inputs.existing_mp3_url }}"
          fi
          test -n "$MP3_URL_INPUT" || { echo "No MP3 URL for Deepgram"; exit 0; }

          # Fetch MP3 locally for POST-binary (Deepgram recommends stream)
          curl -fsSL "$MP3_URL_INPUT" -o "$WORKDIR/dg.mp3"

          # JSON transcript
          curl -sS -X POST "https://api.deepgram.com/v1/listen?model=nova-2&diarize=true&punctuate=true&smart_format=true" \
            -H "Authorization: Token ${DEEPGRAM_API_KEY}" \
            -H "Content-Type: audio/mpeg" \
            --data-binary @"$WORKDIR/dg.mp3" \
            -o "$WORKDIR/dg.json"

          # Extract plain transcript lines (best-effort)
          jq -r '.results.channels[0].alternatives[0].transcript // empty' "$WORKDIR/dg.json" > "$ARTDIR/transcript.txt" || true

          # VTT
          curl -sS -X POST "https://api.deepgram.com/v1/listen?model=nova-2&diarize=true&punctuate=true&smart_format=true&format=vtt" \
            -H "Authorization: Token ${DEEPGRAM_API_KEY}" \
            -H "Content-Type: audio/mpeg" \
            --data-binary @"$WORKDIR/dg.mp3" \
            -o "$ARTDIR/captions.vtt"

          # Upload VTT (public)
          VTT_NAME="${{ steps.names.outputs.vtt_name }}"
          if [ -s "$ARTDIR/captions.vtt" ]; then
            gsutil -m cp -a public-read "$ARTDIR/captions.vtt" "${GS_PREFIX}/${VTT_NAME}"
            echo "vtt_url=${PUBLIC_BASE}/${PREFIX}/${VTT_NAME}" >> "$GITHUB_OUTPUT"
          fi

      - name: Register assets to WordPress (full register)
        if: ${{ env.WP_BASE_URL != '' && env.WP_USER != '' && env.WP_APP_PASSWORD != '' && (env.MODE != 'attendees_only') }}
        shell: bash
        run: |
          set -euo pipefail
          # Choose MP3 URL for register:
          MP3_URL="${{ steps.up_mp3.outputs.mp3_url }}"
          if [ -z "$MP3_URL" ] && [ "${MODE}" = "transcript_only" ] && [ -n "${{ inputs.existing_mp3_url }}" ]; then
            MP3_URL="${{ inputs.existing_mp3_url }}"
          fi
          test -n "$MP3_URL" || { echo "No audio URL to register"; exit 1; }

          # Optional transcript text
          TXTBODY=""
          if [ -s "$ARTDIR/transcript.txt" ]; then
            TXTBODY="$(cat "$ARTDIR/transcript.txt")"
          fi

          # VTT URL (maybe empty)
          VTT_URL="${{ steps.dg.outputs.vtt_url }}"
          SPACE_DATE="${SPACE_TS}"

          # Build payload
          jq -n \
            --arg post_id "${{ inputs.post_id }}" \
            --arg title    "${{ inputs.title }}" \
            --arg gcs_url  "$MP3_URL" \
            --arg mime     "audio/mpeg" \
            --arg vtt_url  "${VTT_URL:-}" \
            --arg transcript "$TXTBODY" \
            --arg attendees_html "$(cat "$ARTDIR/attendees.html")" \
            --argjson attendees_json "$(cat "$ARTDIR/attendees_grouped.json")" \
            --arg space_date "$SPACE_DATE" \
            --arg att_html_url "${{ steps.up_att.outputs.att_html_url }}" \
            --arg att_json_url "${{ steps.up_att.outputs.att_json_url }}" \
            --arg source "${{ steps.peek.outputs.source }}" \
            '{
              title: ($title // ""),
              gcs_url: $gcs_url,
              mime: $mime,
              vtt_url: ($vtt_url // null),
              transcript: (if ($transcript|length)>0 then $transcript else null end),
              attendees_html: $attendees_html,
              attendees_json: $attendees_json,
              artifacts: { attendees_html_url: $att_html_url, attendees_json_url: $att_json_url, attendees_source: $source },
              space_date: $space_date
            } + (if ($post_id|length)>0 then {post_id: ($post_id|tonumber)} else {} end)' > "$WORKDIR/register.json"

          # Decide endpoint: register (final)
          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
            -H "Content-Type: application/json" \
            -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/register" \
            -d @"$WORKDIR/register.json"

          # Final progress
          if [ -n "${{ inputs.post_id }}" ]; then
            curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
              -H "Content-Type: application/json" \
              -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/worker-status" \
              -d "$(jq -n --arg pid "${{ inputs.post_id }}" \
                         --arg status "complete" \
                         --arg msg "All assets registered (audio, attendees, transcript/VTT as available)." \
                         --argjson progress 100 \
                         '{post_id: ($pid|tonumber), status:$status, message:$msg, progress:$progress, run_id:"'${{ github.run_id }}'"}')"
          fi

      - name: Patch assets to WordPress (transcript_only mode)
        if: ${{ env.WP_BASE_URL != '' && env.WP_USER != '' && env.WP_APP_PASSWORD != '' && (env.MODE == 'transcript_only') && inputs.post_id != '' }}
        shell: bash
        run: |
          set -euo pipefail
          VTT_URL="${{ steps.dg.outputs.vtt_url }}"
          TXTBODY=""
          if [ -s "$ARTDIR/transcript.txt" ]; then
            TXTBODY="$(cat "$ARTDIR/transcript.txt")"
          fi
          curl -sS -u "${WP_USER}:${WP_APP_PASSWORD}" \
            -H "Content-Type: application/json" \
            -X POST "${WP_BASE_URL%/}/wp-json/ss3k/v1/patch-assets" \
            -d "$(jq -n \
                  --arg pid "${{ inputs.post_id }}" \
                  --arg vtt_url "${VTT_URL:-}" \
                  --arg transcript "$TXTBODY" \
                  --arg attendees_html "$(cat "$ARTDIR/attendees.html")" \
                  --argjson attendees_json "$(cat "$ARTDIR/attendees_grouped.json")" \
                  --arg att_html_url "${{ steps.up_att.outputs.att_html_url }}" \
                  --arg att_json_url "${{ steps.up_att.outputs.att_json_url }}" \
                  --arg source "${{ steps.peek.outputs.source }}" \
                  --arg space_date "${SPACE_TS}" \
                  --arg status "complete" \
                  --arg msg "Transcript/VTT updated; attendees saved." \
                  --argjson progress 100 \
                  '{
                    post_id: ($pid|tonumber),
                    vtt_url: (if ($vtt_url|length)>0 then $vtt_url else null end),
                    transcript: (if ($transcript|length)>0 then $transcript else null end),
                    attendees_html: $attendees_html,
                    attendees_json: $attendees_json,
                    artifacts: { attendees_html_url: $att_html_url, attendees_json_url: $att_json_url, attendees_source: $source },
                    space_date: $space_date,
                    status: $status,
                    message: $msg,
                    progress: $progress
                  }')"
